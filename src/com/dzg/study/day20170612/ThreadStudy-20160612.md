## 一、==synchronized 同步方法==
### 1.方法内的变量不存在线程安全问题，永远是线程安全的。
原因：方法内部的变量是私有的

### 2.实例对象非线程安全
添加关键词 **==synchronized==** 可以使之同步.    
多个线程访问同一个对象的同步方法是一点线程安全的.

### 3.多个对象多个锁
多个线程访问多个对象，JVM会创建多个锁，synchronized取得的锁都是对象锁.

### 4.synchronized方法和锁对象
**只有==共享==资源的读写才需要同步执行**，反之不需要.   
同一个对象，A线程持有Lock锁，B线程可调用该对象中非同步(异步)方法，调用该对象的同步方法则需等待.

### 5.脏读
不同线程“争抢”实例变量会出现，对共享资源操作应该是要同步进行.

### 6.synchronized锁重入
当A线程获取对象锁，再次请求此对象锁还是可以再次获得该对象的锁.   
**在一个synchronized方法中调用本类的另一个synchronized方法时，是永远可以得到锁，会同步顺序执行**.   
同上，父子类继承，子类可以通过"可重入锁"调用父类的同步方法.

### 7.出现异常，锁自动释放
a方法同步，A线程调用(锁住)，B线程调用(等待)，a方法抛出异常，自动解锁，B线程正常进入. 

### 8.同步不具备继承性
父类的方法同步，子类重写，该方法不具备同步性，必须添加synchronized.